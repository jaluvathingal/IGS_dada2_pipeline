[1mdiff --git a/illumina_dada2.pl b/illumina_dada2.pl[m
[1mindex 5bd6104..5836e61 100755[m
[1m--- a/illumina_dada2.pl[m
[1m+++ b/illumina_dada2.pl[m
[36m@@ -1,8 +1,7 @@[m
 #!/usr/bin/env perl[m
 #. /usr/local/packages/usepackage/share/usepackage/use.bsh[m
[31m-use File::Basename;[m
[31m-use File::Spec;[m
[31m-my $pipelineDir = dirname(__FILE__);[m
[32m+[m[32mrequire File::Basename;[m
[32m+[m[32mmy $pipelineDir = File::Basename::dirname(__FILE__);[m
 [m
 =head1 NAME[m
 [m
[36m@@ -59,29 +58,39 @@[m [mqsub -cwd -b y -l mem_free=1G -P jravel-lab -q threaded.q -pe thread 4 -V[m
   -p <project name> -r <run ID> -m <mapping file> -v <variable region> [m
   -sd <storage directory> --1Step[m
 [m
[32m+[m[32mqsub -cwd -b y -l mem_free=1G -P jravel-lab -q threaded.q -pe thread 4 -V[m
[32m+[m[32m  -e <path_to_logs> -o <path_to_logs> illumina_dada2.pl -r1 <path_to_R1_file>[m
[32m+[m[32m  -r2 <path_to_R2_file> -p <project name> -r <run ID> -m <mapping file>[m
[32m+[m[32m  -v <variable region> -sd <storage directory> --1Step[m
[32m+[m
 =head1 OPTIONS[m
 [m
 =over[m
 [m
 =item B<--raw-path>=path, B<-i> path[m
 [m
[31m-Single full path to directory containing raw R1, R2, R3, and R4 files[m
[32m+[m[32mSingle full path to directory containing raw R1, R2, R3, and R4 files, or R1,[m[41m [m
[32m+[m[32mR2, I1, and I2 files. Incompatible with -r1, -r2, -r3, and -r4.[m
 [m
 =item B<--r1-path>=file, B<-r1> file[m
 [m
[31m-Full path to raw R1 read file (forward read file, or r1) (.fastq.gz).[m
[32m+[m[32mFull path to raw R1 read file (forward read file, or r1) (.fastq.gz).[m[41m [m
[32m+[m[32mIncompatible with b<--raw-path, -i>.[m
 [m
 =item B<--r2-path>=file, B<-r2> file[m
 [m
[31m-Full path to raw R2 read file (barcode file, or i1) (.fastq.gz).[m
[32m+[m[32mFull path to raw R2 read file (barcode file, or i1) (.fastq.gz). Incompatible[m[41m [m
[32m+[m[32mwith b<--raw-path, -i>.[m
 [m
 =item B<--r3-path>=file, B<-r3> file[m
 [m
[31m-Full path to raw R3 read file (barcode file, or i2) (.fastq.gz).[m
[32m+[m[32mFull path to raw R3 read file (barcode file, or i2) (.fastq.gz). Incompatible[m[41m [m
[32m+[m[32mwith b<--raw-path, -i>. Ignored when --1Step given.[m
 [m
 =item B<--r4-path>=file, B<-r4> file[m
 [m
[31m-Full path to raw R4 read file (reverse read file, r2 or r4) (.fastq.gz).[m
[32m+[m[32mFull path to raw R4 read file (reverse read file, r2 or r4) (.fastq.gz).[m[41m [m
[32m+[m[32mIncompatible with b<--raw-path, -i>. Ignored when --1Step given.[m
 [m
 =item B<--project-name>=name, B<-p> name[m
 [m
[36m@@ -141,8 +150,8 @@[m [muse English qw( -no_match_vars );[m
 use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through);[m
 use Cwd qw(abs_path);[m
 use File::Temp qw/ tempfile /;[m
[31m-use File::Basename;[m
 use POSIX;[m
[32m+[m[32muse File::Spec::Functions;[m
 [m
 $OUTPUT_AUTOFLUSH = 1;[m
 [m
[36m@@ -151,6 +160,7 @@[m [m$OUTPUT_AUTOFLUSH = 1;[m
 ####################################################################[m
 [m
 my @dbg;[m
[32m+[m[32mmy $oneStep = 0;[m
 GetOptions([m
     "raw-path|i=s"           => \my $inDir,[m
     "r1-path|r1=s"           => \my $r1file,[m
[36m@@ -165,6 +175,7 @@[m [mGetOptions([m
     "dbg:s"                  => \@dbg,[m
     "verbose"                => \my $verbose,[m
     "dry-run"                => \my $dryRun,[m
[32m+[m[32m    "nocheck"                => \my $noCheck,[m
     "skip-err-thld"          => \my $skipErrThldStr,[m
     "dada2-truncLen-f|for:i" => \my $f,[m
     "dada2-truncLen-r|rev:i" => \my $r,[m
[36m@@ -175,7 +186,7 @@[m [mGetOptions([m
     "dada2-maxLen:s"         => \my $maxLen,[m
     "dada2-minLen:s"         => \my $minLen,[m
     "dada2-minQ:s"           => \my $minQ,[m
[31m-    "1Step"                  => \my $oneStep,[m
[32m+[m[32m    "1Step"                  => \$oneStep,[m
     "storage-dir|sd=s"       => \my $sd,[m
     "qsub-project|qp:s"      => \my $qproj,[m
   )[m
[36m@@ -202,12 +213,28 @@[m [mif ($help) {[m
     exit 1;[m
 }[m
 [m
[31m-if ( !$inDir && !$r1file && !$r2file && !$r3file && !$r4file ) {[m
[31m-    print "\n\tPlease provide the location of the raw sequencing files "[m
[31m-      . "(single directory => -i)\n\t\tOR \n\tFull paths to each R1, R2, R3, "[m
[31m-      . "and R4 file => -r1, -r2, -r3, -r4)\n\n";[m
[31m-    pod2usage( verbose => 2, exitstatus => 0 );[m
[31m-    exit 1;[m
[32m+[m[32mif ([m
[32m+[m[32m    !$inDir[m
[32m+[m[32m    && !([m
[32m+[m[32m           ( !$oneStep && $r1file && $r2file && $r3file && $r4file )[m
[32m+[m[32m        || ( $oneStep && $r1file && $r2file )[m
[32m+[m[32m    )[m
[32m+[m[32m  )[m
[32m+[m[32m{[m
[32m+[m[32m    my $parameters = $oneStep ? "-r1, -r2" : "-r1, -r2, -i1, -i2";[m
[32m+[m[32m    die "\n\tPlease provide the location of the raw sequencing files "[m
[32m+[m[32m      . "(single directory => -i)\n\t\tOR \n\tFull paths to each raw file => "[m
[32m+[m[32m      . "$parameters)\n\n";[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mif ( $oneStep && ( $r3file || $r4file ) ) {[m
[32m+[m[32m    die "\n\t--1Step is incompatible with -r3 and -r4.\n\n";[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mif ( $inDir && ( $r1file || $r2file || $r3file || $r4file ) ) {[m
[32m+[m[32m    die[m
[32m+[m[32m"\n\tInput directory (-i) and raw files (-r*) were both specified. Please "[m
[32m+[m[32m      . "provide one or the other.\n\n";[m
 }[m
 [m
 if ( !$map ) {[m
[36m@@ -227,11 +254,8 @@[m [mif ( $var eq 'V4' || $var eq 'ITS' ) {[m
     $models = "PECAN not used.\n";[m
 }[m
 if ( !$sd ) {[m
[31m-    print "\n***Please choose a storage directory (-sd), either 'scratch' or "[m
[31m-      . "'groupshare'.";[m
[31m-    print "\nOR provide a full path to an existing directory.";[m
[31m-    pod2usage( verbose => 2, exitstatus => 0 );[m
[31m-    die;[m
[32m+[m[32m    die "\n***Please choose a storage directory (-sd), either 'scratch' or "[m
[32m+[m[32m      . "'groupshare'.\nOR provide a full path to an existing directory.";[m
 }[m
 [m
 if ( $f && !$r ) {[m
[36m@@ -254,6 +278,9 @@[m [mmy $R = "/usr/local/packages/r-3.4.0/bin/R";[m
 ####################################################################[m
 my $pd;[m
 my $wd;[m
[32m+[m[32mif ($inDir) {[m
[32m+[m[32m    $inDir =~ s/\/$//;    # remove trailing slash[m
[32m+[m[32m}[m
 [m
 if ( $sd eq "scratch" ) {[m
     $pd = "/local/scratch/$project";[m
[36m@@ -271,42 +298,41 @@[m [mmy $stdout_log = "$wd/qsub_stdout_logs";[m
 ## Instead of working directory, give option for provided directory (or current[m
 #  working directory)[m
 [m
[31m-my $r1split;[m
[31m-my $r4split;[m
[32m+[m[32mmy $rForSplit;[m
[32m+[m[32mmy $rRevSplit;[m
 [m
[31m-my $r1 = "$wd/$project" . "_" . "$run" . "_"[m
[31m-  . "R1.fastq";    ## change to full path (flag)[m
[31m-my $r2 = "$wd/$project" . "_" . "$run" . "_"[m
[31m-  . "R2.fastq";    ## change to full path (flag)[m
[31m-my $r3 = "$wd/$project" . "_" . "$run" . "_"[m
[31m-  . "R3.fastq";    ## change to full path - usr provides full path (flag)[m
[31m-my $r4;[m
[32m+[m[32m# my $r1 = "$wd/$project" . "_" . "$run" . "_"[m
[32m+[m[32m#   . "R1.fastq";    ## change to full path (flag)[m
[32m+[m[32m# my $r2 = "$wd/$project" . "_" . "$run" . "_"[m
[32m+[m[32m#   . "R2.fastq";    ## change to full path (flag)[m
[32m+[m[32m# my $r3 = "$wd/$project" . "_" . "$run" . "_"[m
[32m+[m[32m#   . "R3.fastq";    ## change to full path - usr provides full path (flag)[m
[32m+[m[32m# my $r4;[m
 [m
 if ($oneStep) {[m
[31m-    $r1split = "$wd/R1split";[m
[31m-    $r4split = "$wd/R2split";[m
[31m-    $r4      = "$wd/$project" . "_" . "$run" . "_" . "R2.fastq";[m
[32m+[m[32m    $rForSplit = "$wd/R1split";[m
[32m+[m[32m    $rRevSplit = "$wd/R2split";[m
[32m+[m
[32m+[m[32m    # $r4      = "$wd/$project" . "_" . "$run" . "_" . "R2.fastq";[m
 } else {[m
[31m-    $r1split = "$wd/R1split";[m
[31m-    $r4split = "$wd/R4split";[m
[31m-    $r4      = "$wd/$project" . "_" . "$run" . "_" . "R4.fastq";[m
[31m-}[m
[32m+[m[32m    $rForSplit = "$wd/R1split";[m
[32m+[m[32m    $rRevSplit = "$wd/R4split";[m
 [m
[31m-my $r1fq = "$r1split/seqs.fastq";[m
[31m-my $r4fq = "$r4split/seqs.fastq";[m
[32m+[m[32m    # $r4      = "$wd/$project" . "_" . "$run" . "_" . "R4.fastq";[m
[32m+[m[32m}[m
 [m
[31m-my $r1seqs = "$r1split/split_by_sample_out";[m
[31m-my $r4seqs = "$r4split/split_by_sample_out";[m
[32m+[m[32mmy $r1seqs = "$rForSplit/split_by_sample_out";[m
[32m+[m[32mmy $r4seqs = "$rRevSplit/split_by_sample_out";[m
 my $cmd;[m
 [m
[31m-my $split_log = "$r1split/split_library_log.txt";[m
[32m+[m[32mmy $split_log = "$rForSplit/split_library_log.txt";[m
 my @split;[m
 my $newSamNo;[m
 [m
 my @errors;[m
[31m-my $qiime;[m
[32m+[m[32mmy $qiime = "$wd/$project" . "_" . $run . "_" . "qiime_config.txt";[m
 [m
[31m-###### BEGIN MAKE WORKING DIRECTORIES ##########[m
[32m+[m[32m###### BEGIN MAKE WORKING DIRECTORIES / VALIDATE INPUT FILES ##########[m
 ################################################[m
 [m
 if ( !-e $pd ) {[m
[36m@@ -336,23 +362,12 @@[m [msystem( $^X, $perlScript, $log );[m
 open my $logFH, ">>$log" or die "Cannot open $log for writing: $OS_ERROR";[m
 print $logFH "$time\n";[m
 [m
[31m-if (@dbg) {[m
[31m-    print "DBG FLAGS: ";[m
[31m-    print $logFH "DBG FLAGS: ";[m
[31m-    for (@dbg) {[m
[31m-        print "$_ ";[m
[31m-        print $logFH "$_ ";[m
[31m-    }[m
[31m-    print "\n";[m
[31m-    print $logFH "\n";[m
[31m-}[m
[31m-[m
 if ( ( !@dbg ) || grep( /^qiime_and_validation$/, @dbg ) ) {[m
 [m
     ###### BEGIN CHECK OF QIIME CONFIGURATION ###########[m
     #####################################################[m
[31m-    $qiime = "$wd/$project" . "_" . $run . "_" . "qiime_config.txt";[m
[31m-    $cmd   = "print_qiime_config.py > $qiime";[m
[32m+[m
[32m+[m[32m    $cmd = "print_qiime_config.py > $qiime";[m
     print "\tcmd=$cmd\n" if $verbose;[m
     system($cmd) == 0[m
       or die "system($cmd) failed with exit code: $?"[m
[36m@@ -393,65 +408,64 @@[m [mif ( ( !@dbg ) || grep( /^qiime_and_validation$/, @dbg ) ) {[m
     } else {[m
         die "validate_mapping_file.py did not produce an error log";[m
     }[m
[31m-    if ( @dbg && !grep( /^extract_barcodes$/, @dbg ) ) {[m
[31m-        die[m
[31m-"Finished printing QIIME configuration and validating mapping file. Terminated "[m
[31m-          . "because -dbg extract_barcodes was not specified.";[m
[31m-    }[m
[31m-}[m
 [m
[31m-open MAP, "<$map" or die "Cannot open $map for reading: $OS_ERROR";[m
[31m-my $nSamples    = 0;[m
[31m-my $extctrl     = 0;[m
[31m-my $pcrpos      = 0;[m
[31m-my $pcrneg      = 0;[m
[31m-my $projSamples = 0;[m
[31m-my $linecount   = 0;[m
[31m-my $null        = 0;[m
[31m-while (<MAP>) {[m
[31m-    chomp;[m
[31m-    $linecount++;[m
[31m-    if ( $linecount > 1 )    ## don't count header as sample[m
[31m-    {[m
[31m-        if (   $_ =~ "EXTNTC"[m
[31m-            || $_ =~ "NTC.EXT"[m
[31m-            || $_ =~ "NTCEXT"[m
[31m-            || $_ =~ "EXT.NTC"[m
[31m-            || $_ =~ "NTC"[m
[31m-            || $_ =~ "EXTNEG" )[m
[31m-        {[m
[31m-            $extctrl++;[m
[31m-        } elsif ( $_ =~ "PCRPOS"[m
[31m-            || $_ =~ "PCR.pos"[m
[31m-            || $_ =~ "pCR.pos"[m
[31m-            || $_ =~ "POSCTRL"[m
[31m-            || $_ =~ "POS.CTRL"[m
[31m-            || $_ =~ "POSCON"[m
[31m-            || $_ =~ "posctr" )[m
[31m-        {[m
[31m-            $pcrpos++;[m
[31m-        } elsif ( $_ =~ "PCRNTC"[m
[31m-            || $_ =~ "PCR.NEG"[m
[31m-            || $_ =~ "PCR.NTC"[m
[31m-            || $_ =~ "PCRNEG"[m
[31m-            || $_ =~ "PCRNEGCTRL"[m
[31m-            || $_ =~ "ntcctr" )[m
[31m-        {[m
[31m-            $pcrneg++;[m
[31m-        } elsif ( $_ =~ /NULL/ ) {[m
[31m-            $null++;[m
[31m-        } else {[m
[31m-            $projSamples++;[m
[32m+[m[32m    if (@dbg) {[m
[32m+[m[32m        print "DBG FLAGS: ";[m
[32m+[m[32m        print $logFH "DBG FLAGS: ";[m
[32m+[m[32m        for (@dbg) {[m
[32m+[m[32m            print "$_ ";[m
[32m+[m[32m            print $logFH "$_ ";[m
         }[m
[32m+[m[32m        print "\n";[m
[32m+[m[32m        print $logFH "\n";[m
     }[m
[31m-}[m
[31m-close MAP;[m
 [m
[31m-$nSamples = $projSamples + $extctrl + $pcrpos + $pcrneg + $null;[m
[31m-[m
[31m-my $barcodes = "$wd/barcodes.fastq";[m
[32m+[m[32m    open MAP, "<$map" or die "Cannot open $map for reading: $OS_ERROR";[m
[32m+[m[32m    my $extctrl     = 0;[m
[32m+[m[32m    my $pcrpos      = 0;[m
[32m+[m[32m    my $pcrneg      = 0;[m
[32m+[m[32m    my $projSamples = 0;[m
[32m+[m[32m    my $linecount   = 0;[m
[32m+[m[32m    my $null        = 0;[m
[32m+[m[32m    while (<MAP>) {[m
[32m+[m[32m        chomp;[m
[32m+[m[32m        if ( $. > 1 )    ## don't count header as sample[m
[32m+[m[32m        {[m
[32m+[m[32m            if (   $_ =~ "EXTNTC"[m
[32m+[m[32m                || $_ =~ "NTC.EXT"[m
[32m+[m[32m                || $_ =~ "NTCEXT"[m
[32m+[m[32m                || $_ =~ "EXT.NTC"[m
[32m+[m[32m                || $_ =~ "NTC"[m
[32m+[m[32m                || $_ =~ "EXTNEG" )[m
[32m+[m[32m            {[m
[32m+[m[32m                $extctrl++;[m
[32m+[m[32m            } elsif ( $_ =~ "PCRPOS"[m
[32m+[m[32m                || $_ =~ "PCR.pos"[m
[32m+[m[32m                || $_ =~ "pCR.pos"[m
[32m+[m[32m                || $_ =~ "POSCTRL"[m
[32m+[m[32m                || $_ =~ "POS.CTRL"[m
[32m+[m[32m                || $_ =~ "POSCON"[m
[32m+[m[32m                || $_ =~ "posctr" )[m
[32m+[m[32m            {[m
[32m+[m[32m                $pcrpos++;[m
[32m+[m[32m            } elsif ( $_ =~ "PCRNTC"[m
[32m+[m[32m                || $_ =~ "PCR.NEG"[m
[32m+[m[32m                || $_ =~ "PCR.NTC"[m
[32m+[m[32m                || $_ =~ "PCRNEG"[m
[32m+[m[32m                || $_ =~ "PCRNEGCTRL"[m
[32m+[m[32m                || $_ =~ "ntcctr" )[m
[32m+[m[32m            {[m
[32m+[m[32m                $pcrneg++;[m
[32m+[m[32m            } elsif ( $_ =~ /NULL/ ) {[m
[32m+[m[32m                $null++;[m
[32m+[m[32m            } else {[m
[32m+[m[32m                $projSamples++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
 [m
[31m-if ( ( !@dbg ) || grep( /^extract_barcodes$/, @dbg ) ) {[m
[32m+[m[32m    }[m
[32m+[m[32m    my $nSamples = $. - 1;[m
[32m+[m[32m    close MAP;[m
 [m
     ###### BEGIN EVALUATION OF SAMPLES VIA MAPPING FILE ###########[m
     ###############################################################[m
[36m@@ -467,6 +481,57 @@[m [mif ( ( !@dbg ) || grep( /^extract_barcodes$/, @dbg ) ) {[m
         print $logFH "\nPCR PREPARATION METHOD: 2-Step\n\n";[m
     }[m
 [m
[32m+[m[32m    if ( @dbg && !grep( /^extract_barcodes$/, @dbg ) ) {[m
[32m+[m[32m        die[m
[32m+[m[32m"Finished printing QIIME configuration and validating mapping file. Terminated "[m
[32m+[m[32m          . "because -dbg extract_barcodes was not specified.";[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    my $index1Input;  # In one-step runs, these are the SAME files pointed to by[m
[32m+[m[32m    my $index2Input;  # $readsForInput and $readsRevInput[m
[32m+[m
[32m+[m[32m    my $readsForInput;[m
[32m+[m[32m    my $readsRevInput;[m
[32m+[m
[32m+[m[32m    if ($inDir) {     # Search for raw fastq's (or fastq.gz's)[m
[32m+[m[32m        ( $readsForInput, $readsRevInput, $index1Input, $index2Input ) =[m
[32m+[m[32m          find_raw_files( $inDir, $oneStep, $logFH );[m
[32m+[m[32m    } else {[m
[32m+[m[32m        if ($oneStep) {[m
[32m+[m[32m            $index1Input = $readsForInput = $r1file;[m
[32m+[m[32m            $index2Input = $readsRevInput = $r2file;[m
[32m+[m[32m        } else {[m
[32m+[m[32m            $readsForInput = $r1file;[m
[32m+[m[32m            $index1Input   = $r2file;[m
[32m+[m[32m            $index2Input   = $r3file;[m
[32m+[m[32m            $readsRevInput = $r4file;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if ($verbose) {[m
[32m+[m[32m        print "Forward and reverse reads will be obtained from:\n"[m
[32m+[m[32m          . "\t$readsForInput\n\t$readsRevInput\n";[m
[32m+[m[32m        print "Index 1 and Index 2 will be obtained from:\n"[m
[32m+[m[32m          . "\t$index1Input\n\t$index2Input\n";[m
[32m+[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    # In the multidbg branch, combine this section with qiime_and_validate[m
[32m+[m
[32m+[m[32m    if ($oneStep) {[m
[32m+[m[32m        print $logFH[m
[32m+[m[32m          "$project raw reads files:\n\t$readsForInput\n\t$readsRevInput\n";[m
[32m+[m[32m    } else {[m
[32m+[m[32m        print $logFH[m
[32m+[m[32m          "$project raw reads files:\n\t$readsForInput\n\t$readsRevInput\n"[m
[32m+[m[32m          . "$project raw index files:\n\t$index1Input\n\t$index2Input\n";[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mif ( ( !@dbg ) || grep( /^extract_barcodes$/, @dbg ) ) {[m
[32m+[m[32m    my $barcodes = "$wd/barcodes.fastq";[m
[32m+[m[32m    my $nSamples = count_samples($map);[m
[32m+[m
     ## change to full path to full barcodes (flag)[m
     my $count = 0;[m
 [m
[36m@@ -476,174 +541,87 @@[m [mif ( ( !@dbg ) || grep( /^extract_barcodes$/, @dbg ) ) {[m
     my $step2;[m
     my $step3;[m
 [m
[31m-    ###### BEGIN 1STEP BARCODES ##########[m
[32m+[m[32m    ###### BEGIN BARCODES ##########[m
     #######################################[m
 [m
[31m-    if ($oneStep) {[m
[31m-        my $r1file = glob("$inDir/*R1.fastq*");[m
[31m-        my $r2file = glob("$inDir/*R2.fastq*");[m
[31m-        if ( !-e $barcodes ) {[m
[31m-            print "---Barcode files not found or were empty\n";[m
[31m-            if ( $inDir && $r1file != /.gz/ ) {[m
[31m-                $r1 = $r1file;[m
[31m-                $r2 = $r2file;[m
[31m-            } else {[m
[31m-                print "---Copying barcode and index files to $wd\n";[m
[31m-                $cmd = "zcat $r1file > $r1 | zcat $r2file > $r2 ";[m
[31m-                print "\tcmd=$cmd\n" if $verbose;[m
[31m-                system($cmd) == 0[m
[31m-                  or die "system($cmd) failed with exit code: $?"[m
[31m-                  if !$dryRun;[m
[31m-                print $logFH[m
[31m-                  "$project barcode and index files copied from $r2file"[m
[31m-                  . " and $r3file to $r1 and $r2\n";[m
[31m-            }[m
[31m-            my $start = time;[m
[31m-            print "---Extracting barcodes and index files\n";[m
[31m-            ## add in (possible replace) awk version of concatenation[m
[31m-            $step1  = "extract_barcodes.py";[m
[31m-            @errors = glob("$error_log/$step1.e*");[m
[31m-            if (@errors) {[m
[31m-                foreach my $error (@errors) {[m
[31m-                    $cmd = "rm $error";[m
[31m-                    print "\tcmd=$cmd\n" if $verbose;[m
[31m-                    system($cmd) == 0[m
[31m-                      or die "system($cmd) failed with exit code: $?"[m
[31m-                      if !$dryRun;[m
[31m-                }[m
[31m-            }[m
[31m-            $cmd =[m
[31m-"qsub -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log extract_barcodes.py -f $r1 -r $r2 -c barcode_paired_end --bc1_len 12 --bc2_len 12 -m $map -o $wd";[m
[31m-            print "\tcmd=$cmd\n" if $verbose;[m
[31m-            system($cmd) == 0[m
[31m-              or die "system($cmd) failed with exit code: $?"[m
[31m-              if !$dryRun;[m
[31m-[m
[31m-            check_error_log( $error_log, $step1 );[m
[32m+[m[32m    if ( !-e $barcodes ) {    # FIXME test if barcodes is the right size[m
[32m+[m[32m        print "---Barcode files not found or were empty\n";[m
 [m
[31m-            print "---Waiting for barcode extraction to complete.\n";[m
[31m-            while ( !( -e $barcodes ) ) { sleep 1; }[m
[31m-[m
[31m-            ## try adding else statement, if needed[m
[31m-            my $duration = time - $start;[m
[31m-            print "---Barcode extraction complete\n";[m
[31m-            print $logFH "---Duration of barcode extraction: $duration s\n";[m
[31m-            print "---Duration of barcode extraction: $duration s\n";[m
[32m+[m[32m        my $start = time;[m
[32m+[m[32m        print "---Extracting barcodes\n";[m
[32m+[m[32m        $step1 = "extract_barcodes.py";[m
[32m+[m
[32m+[m[32m        my $index1Input[m
[32m+[m[32m          ;    # In one-step runs, these are the SAME files pointed to by[m
[32m+[m[32m        my $index2Input;    # $readsForInput and $readsRevInput[m
[32m+[m[32m        my $readsForInput;[m
[32m+[m[32m        my $readsRevInput;[m
[32m+[m[32m        ( $readsForInput, $readsRevInput, $index1Input, $index2Input ) =[m
[32m+[m[32m            $inDir ? find_raw_files( $inDir, $oneStep, $logFH )[m
[32m+[m[32m        : $oneStep ? ( $r1file, $r2file, $r1file, $r2file )[m
[32m+[m[32m        :            ( $r1file, $r4file, $r2file, $r3file );[m
[32m+[m[32m        my %localNames;[m
[32m+[m[32m        @localNames{ ( "readsFor", "readsRev", "index1", "index2" ) } =[m
[32m+[m[32m          convert_to_local_if_gz( $wd, $readsForInput, $readsRevInput,[m
[32m+[m[32m            $index1Input, $index2Input );[m
[32m+[m
[32m+[m[32m        # Get index files as .fastq[m
[32m+[m[32m        my @cmds;[m
[32m+[m[32m        if ( $index1Input !~ /.gz$/ ) {[m
[32m+[m
[32m+[m[32m            # if the index files aren't .gz, just read in place.[m
[32m+[m[32m        } else {    # Otherwise...[m
[32m+[m[32m            my $dest = $localNames{"index1"};[m
[32m+[m
[32m+[m[32m            # decompress to our project/run directory[m
[32m+[m[32m            push( @cmds, "gzip --decompress --force < $index1Input > $dest" );[m
[32m+[m[32m            $index1Input = $dest;[m
[32m+[m[32m        }[m
[32m+[m[32m        if ( $index2Input !~ /.gz$/ ) {    # same for reverse reads[m
         } else {[m
[31m-            open BAR, "<$barcodes"[m
[31m-              or die "Cannot open $barcodes for reading: " . "$OS_ERROR";[m
[31m-            while (<BAR>) { }[m
[31m-            if ( $. = $nSamples ) {[m
[31m-                print "---$barcodes already exists and contains $. entries,"[m
[31m-                  . " as expected\n";[m
[31m-                print $logFH "-> $barcodes already exists and contains $. "[m
[31m-                  . "entries, as expected\n";[m
[31m-            } else {[m
[31m-                print "---$barcodes already exists, but contains $. "[m
[31m-                  . "entries, while there are $nSamples samples. Exiting.\n";[m
[31m-                print $logFH "-> $barcodes already exists, but contains $."[m
[31m-                  . " entries, while there are $nSamples samples. Exiting.\n";[m
[31m-                die;[m
[31m-            }[m
[31m-            close BAR;[m
[32m+[m[32m            my $dest = $localNames{"index2"};[m
[32m+[m[32m            push( @cmds, "gzip --decompress --force < $index2Input > $dest" );[m
[32m+[m[32m            $index2Input = $dest;[m
         }[m
[31m-    } else {[m
[31m-[m
[31m-        ###### BEGIN 2STEP BARCODES ##########[m
[31m-        #######################################[m
[31m-        ## user specified path to barcodes.fastq --- if present, use; if not, then check for existence in cwd, if not, produce[m
[31m-        if ( !( -e $barcodes ) ) {[m
[31m-            print "---Barcode files not found or were empty\n";[m
[31m-            if ( !-e $r2 || !-e $r3 ) {[m
[31m-                my $r2 = "$wd/$project" . "_" . "$run" . "_"[m
[31m-                  . "R2.fastq";    ## change to full path (flag)[m
[31m-                my $r3 = "$wd/$project" . "_" . "$run" . "_" . "R3.fastq";[m
[31m-[m
[31m-                if ($inDir) {[m
[31m-                    print "---Copying barcode and index files to $wd\n";[m
[31m-                    $cmd =[m
[31m-"zcat $inDir/*R2.fastq.gz > $r2 | zcat $inDir/*R3.fastq.gz > $r3 ";[m
[31m-                    print "\tcmd=$cmd\n" if $verbose;[m
[31m-                    system($cmd) == 0[m
[31m-                      or die "system($cmd) failed with exit code: $?"[m
[31m-                      if !$dryRun;[m
[31m-                    print $logFH[m
[31m-"$project barcode and index files copied from $inDir to $r2 and $r3\n";[m
[31m-                } else {[m
[31m-                    print "---Copying barcode and index files to $wd\n";[m
[31m-                    $cmd = "zcat $r2file > $r2 | zcat $r3file > $r3 ";[m
[31m-                    print "\tcmd=$cmd\n" if $verbose;[m
[31m-                    system($cmd) == 0[m
[31m-                      or die "system($cmd) failed with exit code: $?"[m
[31m-                      if !$dryRun;[m
[31m-                }[m
[31m-            }[m
 [m
[31m-            my $start = time;[m
[31m-            print "---Extracting barcodes and index files\n";[m
[31m-            ## add in (possible replace) awk version of concatenation[m
[31m-            $step1  = "extract_barcodes.py";[m
[31m-            @errors = glob("$error_log/$step1.e*");[m
[31m-            if (@errors) {[m
[31m-                foreach my $error (@errors) {[m
[31m-                    $cmd = "rm $error";[m
[31m-                    print "\tcmd=$cmd\n" if $verbose;[m
[31m-                    system($cmd) == 0[m
[31m-                      or die "system($cmd) failed with exit code: $?"[m
[31m-                      if !$dryRun;[m
[31m-                }[m
[31m-            }[m
[31m-            $cmd =[m
[31m-"qsub -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log extract_barcodes.py --input_type barcode_paired_end -f $r2 -r $r3 --bc1_len 8 --bc2_len 8 -o $wd";[m
[31m-            print "\tcmd=$cmd\n" if $verbose;[m
[31m-            system($cmd) == 0[m
[31m-              or die "system($cmd) failed with exit code: $?"[m
[31m-              if !$dryRun;[m
[32m+[m[32m        # Execute the commands queued above[m
[32m+[m[32m        if ( scalar @cmds > 0 ) {[m
[32m+[m[32m            print "---Uncompressing raw index file(s) to $wd\n";[m
[32m+[m[32m            execute_and_log( @cmds, 0, $dryRun );[m
[32m+[m[32m            @cmds = ();[m
[32m+[m[32m        }[m
 [m
[31m-            check_error_log( $error_log, $step1 );[m
[32m+[m[32m        my $mapOpt = "";[m
[32m+[m[32m        my $bcLen  = 8;    # 2-step pcr[m
[32m+[m[32m        if ($oneStep) {[m
 [m
[31m-            print "---Waiting for barcode extraction to complete.\n";[m
[32m+[m[32m            # Was in original code, but maybe unnecessary?[m
[32m+[m[32m            $mapOpt = "-m $map";[m
 [m
[31m-            while ( !( -e $barcodes ) ) { sleep 1; }[m
[32m+[m[32m            $bcLen = 12;    # 1-step pcr[m
[32m+[m[32m        }[m
[32m+[m[32m        $cmd =[m
[32m+[m[32m"extract_barcodes.py -f $index1Input -r $index2Input -c barcode_paired_end --bc1_len $bcLen --bc2_len $bcLen $mapOpt -o $wd";[m
[32m+[m[32m        print "\tcmd=$cmd\n" if $verbose;[m
[32m+[m[32m        print "---Waiting for barcode extraction to complete.\n";[m
 [m
[31m-            ## try adding else statement, if needed[m
[31m-            my $duration = time - $start;[m
[31m-            print "---Barcode extraction complete\n";[m
[31m-            print $logFH "---Duration of barcode extraction: $duration s\n";[m
[31m-            print "---Duration of barcode extraction: $duration s\n";[m
[31m-        } else {[m
[31m-            open BAR, "<$barcodes"[m
[31m-              or die "Cannot open $barcodes for reading: " . "$OS_ERROR";[m
[31m-            while (<BAR>) { }[m
[31m-            if ( $. = $nSamples ) {[m
[31m-                print "---$barcodes already exists and contains $. entries,"[m
[31m-                  . " as expected\n";[m
[31m-                print $logFH "-> $barcodes already exists and contains $. "[m
[31m-                  . "entries, as expected\n";[m
[31m-            } else {[m
[31m-                print "---$barcodes already exists, but contains $. "[m
[31m-                  . "entries, while there are $nSamples samples. Exiting.\n";[m
[31m-                print $logFH "-> $barcodes already exists, but contains $."[m
[31m-                  . " entries, while there are $nSamples samples. Exiting.\n";[m
[31m-                die;[m
[31m-            }[m
[31m-            close BAR;[m
[32m+[m[32m        `$cmd` if !$dryRun;[m
[32m+[m[32m        if ( $? && !$dryRun ) {[m
[32m+[m[32m            die $!;[m
         }[m
 [m
[31m-        my $reads1 = "$wd/reads1.fastq";[m
[31m-        my $reads2 = "$wd/reads2.fastq";[m
[31m-        $cmd = "rm -rf $reads1";[m
[31m-        print "\tcmd=$cmd\n" if $verbose;[m
[31m-        system($cmd) == 0[m
[31m-          or die "system($cmd) failed with exit code: $?"[m
[31m-          if !$dryRun;[m
[31m-        $cmd = "rm -rf $reads2";[m
[31m-        print "\tcmd=$cmd\n" if $verbose;[m
[31m-        system($cmd) == 0[m
[31m-          or die "system($cmd) failed with exit code: $?"[m
[31m-          if !$dryRun;[m
[32m+[m[32m        my $duration = time - $start;[m
[32m+[m[32m        print "---Barcode extraction complete\n";[m
[32m+[m[32m        print $logFH "---Duration of barcode extraction: $duration s\n";[m
[32m+[m[32m        print "---Duration of barcode extraction: $duration s\n";[m
     }[m
 [m
[32m+[m[32m    # Delete unneeded output of extract_barcodes.py[m
[32m+[m[32m    my @cmds = ();[m
[32m+[m[32m    push @cmds, "rm -rf $wd/reads1.fastq";[m
[32m+[m[32m    push @cmds, "rm -rf $wd/reads2.fastq";[m
[32m+[m[32m    execute_and_log( @cmds, 0, $dryRun );[m
[32m+[m
     if ( @dbg && !grep( /^demultiplex$/, @dbg ) ) {[m
         die[m
 "Finished extracting barcodes and demultiplexing libraries. Terminated "[m
[36m@@ -657,106 +635,103 @@[m [mif ( ( !@dbg ) || grep( /^extract_barcodes$/, @dbg ) ) {[m
 ## think of way to ensure the consistent read order in the r1 and r4 files.[m
 ## print headers of r1 and r4, comm r1 r4 - to ensure the seqIDs are the same order.[m
 if ( !@dbg || grep( /^demultiplex$/, @dbg ) ) {[m
[31m-    print "--Checking for existence of $r1fq and $r4fq\n";[m
[31m-    if ( !-e $r1fq || !-e $r4fq ) {[m
[31m-        if ($oneStep) {[m
[31m-            print "---Obtaining $project-specific R1 and R2 fastq files\n";[m
[31m-        } else {[m
[31m-            print "---Obtaining $project-specific R1 and R4 fastq files\n";[m
[31m-            if ($inDir) {[m
[31m-                $cmd =[m
[31m-"zcat $inDir/*R1.fastq.gz > $r1 | zcat $inDir/*R4.fastq.gz > $r4 ";[m
[31m-                print "\tcmd=$cmd\n" if $verbose;[m
[31m-                system($cmd) == 0[m
[31m-                  or die "system($cmd) failed with exit code: $?"[m
[31m-                  if !$dryRun;[m
[31m-                print $logFH "---$project barcode and index files copied from"[m
[31m-                  . " $inDir to $r1 and $r4\n";[m
[31m-            } else {[m
[31m-                $cmd = "zcat $r1file > $r1 | zcat $r4file > $r4 ";[m
[31m-                print "\tcmd=$cmd\n" if $verbose;[m
[31m-                system($cmd) == 0[m
[31m-                  or die "system($cmd) failed with exit code: $?"[m
[31m-                  if !$dryRun;[m
[31m-                print $logFH "---$project barcode and index files copied from "[m
[31m-                  . "$r1file and $r4file to $r1 and $r4\n";[m
[31m-            }[m
[31m-        }[m
[32m+[m[32m    my $barcodes = "$wd/barcodes.fastq";[m
[32m+[m[32m    my $nSamples = count_samples($map);[m
[32m+[m
[32m+[m[32m    my @cmds;[m
[32m+[m[32m    my $rForSeqsFq = "$rForSplit/seqs.fastq";[m
[32m+[m[32m    my $rRevSeqsFq = "$rRevSplit/seqs.fastq";[m
[32m+[m
[32m+[m[32m    my $readsForInput;[m
[32m+[m[32m    my $readsRevInput;[m
[32m+[m[32m    my $index1Input;[m
[32m+[m[32m    my $index2Input;[m
[32m+[m[32m    ( $readsForInput, $readsRevInput, $index1Input, $index2Input ) =[m
[32m+[m[32m        $inDir ? find_raw_files( $inDir, $oneStep, $logFH )[m
[32m+[m[32m      : $oneStep ? ( $r1file, $r2file, $r1file, $r2file )[m
[32m+[m[32m      :            ( $r1file, $r4file, $r2file, $r3file );[m
[32m+[m
[32m+[m[32m# split_libraries_fastq.py accepts fastq.gz, so no need to convert_to_local_drop_gz[m
[32m+[m
[32m+[m[32m    # Just helps with printing[m
[32m+[m[32m    my $revName;[m
[32m+[m[32m    if ($oneStep) {[m
[32m+[m[32m        $revName = "R2";[m
[32m+[m[32m    } else {[m
[32m+[m[32m        $revName = "R4";[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if ( !-e $rForSeqsFq || !-e $rRevSeqsFq ) {[m
[32m+[m[32m        print "---Producing $rForSeqsFq and $rRevSeqsFq\n";[m
[32m+[m
[32m+[m[32m#         if ($oneStep) {[m
[32m+[m[32m#             print "---Obtaining $project-specific R1 and R2 fastq files\n";[m
[32m+[m[32m#         } else {[m
[32m+[m[32m#             print "---Obtaining $project-specific R1 and R4 fastq files\n";[m
[32m+[m[32m#             if ($inDir) {[m
[32m+[m[32m#                 $cmd =[m
[32m+[m[32m# "zcat $readsForInput > $r1 | zcat $readsRevInput > $r4 ";[m
[32m+[m[32m#                 print "\tcmd=$cmd\n" if $verbose;[m
[32m+[m[32m#                 system($cmd) == 0[m
[32m+[m[32m#                   or die "system($cmd) failed with exit code: $?"[m
[32m+[m[32m#                   if !$dryRun;[m
[32m+[m[32m#                 print $logFH "---$project barcode and index files copied from"[m
[32m+[m[32m#                   . " $inDir to $r1 and $r4\n";[m
[32m+[m[32m#             } else {[m
[32m+[m[32m#                 $cmd = "zcat $r1file > $r1 | zcat $r4file > $r4 ";[m
[32m+[m[32m#                 print "\tcmd=$cmd\n" if $verbose;[m
[32m+[m[32m#                 system($cmd) == 0[m
[32m+[m[32m#                   or die "system($cmd) failed with exit code: $?"[m
[32m+[m[32m#                   if !$dryRun;[m
[32m+[m[32m#                 print $logFH "---$project barcode and index files copied from "[m
[32m+[m[32m#                   . "$r1file and $r4file to $r1 and $r4\n";[m
[32m+[m[32m#             }[m
[32m+[m[32m#         }[m
 [m
[31m-        print "---Producing $r1fq and $r4fq\n";[m
         my $start = time;[m
         my $step2 = "split_libraries_fastq.py";[m
         @errors = glob("$error_log/$step2.e*");[m
         if (@errors) {[m
             foreach my $error (@errors) {[m
[31m-                $cmd = "rm $error";[m
[31m-                print "\tcmd=$cmd\n" if $verbose;[m
[31m-                system($cmd) == 0[m
[31m-                  or die "system($cmd) failed with exit code: $?"[m
[31m-                  if !$dryRun;[m
[32m+[m[32m                push @cmds, "rm $error";[m
             }[m
[32m+[m[32m            execute_and_log( @cmds, $dryRun );[m
[32m+[m[32m            @cmds = ();[m
         }[m
         ## including the stitch script before so that demultiplex happens by barcode NOT order[m
[32m+[m[32m        my $barcodeType;[m
         if ($oneStep) {[m
[31m-            $cmd =[m
[31m-"qsub -cwd -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log split_libraries_fastq.py -i $r1 -o $r1split -b $barcodes -m $map --max_barcode_errors 1 --store_demultiplexed_fastq --barcode_type 24 -r 999 -n 999 -q 0 -p 0.0001";[m
[31m-            print "\tcmd=$cmd\n" if $verbose;[m
[31m-            system($cmd) == 0[m
[31m-              or die "system($cmd) failed with exit code: $?"[m
[31m-              if !$dryRun;[m
[31m-            print $logFH "Demultiplexing command F: \n\t$cmd\n\n";[m
[31m-            $cmd =[m
[31m-"qsub -cwd -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log split_libraries_fastq.py -i $r4 -o $r4split -b $barcodes -m $map --max_barcode_errors 1 --store_demultiplexed_fastq --barcode_type 24 -r 999 -n 999 -q 0 -p 0.0001";[m
[31m-            print "\tcmd=$cmd\n" if $verbose;[m
[31m-            system($cmd) == 0[m
[31m-              or die "system($cmd) failed with exit code: $?"[m
[31m-              if !$dryRun;[m
[31m-            print $logFH "Demultiplexing command R: \n\t$cmd\n\n";[m
[32m+[m[32m            $barcodeType = "24";[m
         } else {[m
[31m-            $cmd =[m
[31m-"qsub -cwd -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log split_libraries_fastq.py -i $r1 -o $r1split -b $barcodes -m $map --max_barcode_errors 1 --store_demultiplexed_fastq --barcode_type 16 -r 999 -n 999 -q 0 -p 0.0001";[m
[31m-            print "\tcmd=$cmd\n" if $verbose;[m
[31m-            system($cmd) == 0[m
[31m-              or die "system($cmd) failed with exit code: $?"[m
[31m-              if !$dryRun;[m
[31m-            print $logFH "Demultiplexing command F: \n\t$cmd\n\n";[m
[31m-            $cmd =[m
[31m-"qsub -cwd -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log split_libraries_fastq.py -i $r4 -o $r4split -b $barcodes -m $map --max_barcode_errors 1 --store_demultiplexed_fastq --barcode_type 16 -r 999 -n 999 -q 0 -p 0.0001";[m
[31m-            print "\tcmd=$cmd\n" if $verbose;[m
[31m-            system($cmd) == 0[m
[31m-              or die "system($cmd) failed with exit code: $?"[m
[31m-              if !$dryRun;[m
[31m-            print $logFH "Demultiplexing command R: \n\t$cmd\n\n";[m
[32m+[m[32m            $barcodeType = "16";[m
         }[m
 [m
[31m-        check_error_log( $error_log, $step2 );[m
[32m+[m[32m        push @cmds,[m
[32m+[m[32m"qsub -cwd -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log $step2 -i $readsForInput -o $rForSplit -b $barcodes -m $map --max_barcode_errors 1 --store_demultiplexed_fastq --barcode_type $barcodeType -r 999 -n 999 -q 0 -p 0.0001";[m
[32m+[m[32m        push @cmds,[m
[32m+[m[32m"qsub -cwd -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log $step2 -i $readsRevInput -o $rRevSplit -b $barcodes -m $map --max_barcode_errors 1 --store_demultiplexed_fastq --barcode_type $barcodeType -r 999 -n 999 -q 0 -p 0.0001";[m
[32m+[m[32m        print $logFH "Demultiplexing commands: \n";[m
[32m+[m[32m        execute_and_log( @cmds, $logFH, $dryRun );[m
[32m+[m[32m        @cmds = ();[m
[32m+[m[32m        print $logFH "\n\n";[m
 [m
[31m-        $r1fq = "$r1split/seqs.fastq";[m
[31m-        $r4fq = "$r4split/seqs.fastq";[m
[32m+[m[32m        check_error_log( $error_log, $step2 );[m
 [m
         print "---Waiting for R1 seqs.fastq to complete.\n";[m
[31m-        while ( !( -e $r1fq ) ) { sleep 1; }[m
[32m+[m[32m        while ( !( -e $rForSeqsFq ) ) { sleep 1; }[m
         my $duration = time - $start;[m
         print $logFH "---Duration of R1 seqs.fastq production: $duration s\n";[m
         print "---Duration of R1 seqs.fastq production: $duration s\n";[m
 [m
[31m-        if ($oneStep) {[m
[31m-            print "---Waiting for R2 seqs.fastq to complete.\n";[m
[31m-        } else {[m
[31m-            print "---Waiting for R4 seqs.fastq to complete.\n";[m
[31m-        }[m
[31m-        while ( !( -e $r4fq ) ) { sleep 1; }[m
[32m+[m[32m        print "---Waiting for $revName seqs.fastq to complete.\n";[m
[32m+[m[32m        while ( !( -e $rRevSeqsFq ) ) { sleep 1; }[m
         $duration = time - $start;[m
[31m-        if ($oneStep) {[m
[31m-            print $logFH "---Duration of R2 seqs.fastq production: $duration s"[m
[31m-              . "\n";[m
[31m-            print "---Duration of R2 seqs.fastq production: $duration s\n";[m
[31m-        } else {[m
[31m-            print $logFH "Duration of R4 seqs.fastq production: $duration s\n";[m
[31m-            print "---Duration of R4 seqs.fastq production: $duration s\n";[m
[31m-        }[m
[32m+[m[32m        print $logFH "---Duration of $revName seqs.fastq production: "[m
[32m+[m[32m          . "$duration s\n";[m
[32m+[m[32m        print "---Duration of $revName seqs.fastq production: $duration s\n";[m
[32m+[m
     } else {[m
[31m-        print "-> $r1fq and $r4fq fastq files already produced. Demultiplexing "[m
[32m+[m[32m        print "-> $rForSeqsFq and $rRevSeqsFq already produced. Demultiplexing "[m
           . "...\n";[m
     }[m
 [m
[36m@@ -773,7 +748,7 @@[m [mif ( !@dbg || grep( /^demultiplex$/, @dbg ) ) {[m
             if ( $nReads eq "0" ) {[m
                 push @split, $sample;[m
             } else {[m
[31m-                print "$sample $nReads\n";[m
[32m+[m[32m                print "$_";[m
             }[m
         }[m
     }[m
[36m@@ -800,64 +775,50 @@[m [mif ( !@dbg || grep( /^demultiplex$/, @dbg ) ) {[m
     ###### BEGIN SPLIT BY SAMPLE ##########[m
     #######################################[m
 [m
[31m-    if ($oneStep) {[m
[31m-        print "--Checking if $project R1 & R2 seqs.fastq files were split by "[m
[31m-          . "sample ID\n";[m
[31m-    } else {[m
[31m-        print "--Checking if $project R1 & R4 seqs.fastq files were split by "[m
[31m-          . "sample ID\n";[m
[31m-    }[m
[32m+[m[32m    print "--Checking if $project R1 & $revName seqs.fastq files were split by "[m
[32m+[m[32m      . "sample ID\n";[m
 [m
     my $n_fq1 = 0;[m
 [m
[31m-    my @filenames   = glob("$r1seqs/*.fastq");[m
[31m-    my @r4filenames = glob("$r4seqs/*.fastq");[m
[32m+[m[32m    my @forFilenames = glob("$r1seqs/*.fastq");[m
[32m+[m[32m    my @revFilenames = glob("$r4seqs/*.fastq");[m
 [m
[31m-    if ( scalar(@filenames) != $newSamNo || scalar(@r4filenames) != $newSamNo )[m
[32m+[m[32m    if (   scalar(@forFilenames) != $newSamNo[m
[32m+[m[32m        || scalar(@revFilenames) != $newSamNo )[m
     {[m
         print "There are "[m
[31m-          . scalar @filenames[m
[32m+[m[32m          . scalar @forFilenames[m
           . " split files. Waiting for $newSamNo "[m
           . "files\n";[m
         my $step3 = "split_sequence_file_on_sample_ids.py";[m
         @errors = glob("$error_log/$step3.e*");[m
         if (@errors) {[m
             foreach my $error (@errors) {[m
[31m-                $cmd = "rm $error";[m
[31m-                print "\tcmd=$cmd\n" if $verbose;[m
[31m-                system($cmd) == 0[m
[31m-                  or die "system($cmd) failed with exit code: " . "$?"[m
[31m-                  if !$dryRun;[m
[32m+[m[32m                push( @cmds, "rm $error" );[m
             }[m
[32m+[m[32m            execute_and_log( @cmds, 0, $dryRun );[m
[32m+[m[32m            @cmds = ();[m
         }[m
         print "---Sample specific files not found or completed... Splitting "[m
           . "$project seqs.fastq files by sample ID\n";[m
         print $logFH "There are "[m
[31m-          . scalar(@filenames)[m
[32m+[m[32m          . scalar(@forFilenames)[m
           . " sample specific "[m
           . "files found (expected $newSamNo)... Splitting $project seqs.fastq "[m
           . "files by sample ID\n";[m
[31m-        $cmd = "rm -rf $r1seqs; rm -rf $r4seqs";[m
[31m-        print "\tcmd=$cmd\n" if $verbose;[m
[31m-        system($cmd) == 0[m
[31m-          or die "system($cmd) failed with exit code: $?"[m
[31m-          if !$dryRun;[m
[32m+[m[32m        execute_and_log( "rm -rf $r1seqs; rm -rf $r4seqs", 0, $dryRun );[m
 [m
[31m-        while ( !( -e $r1fq ) ) { sleep 1; }[m
[31m-        $cmd =[m
[31m-"qsub -cwd -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log -V split_sequence_file_on_sample_ids.py -i $r1fq --file_type fastq -o $r1seqs";[m
[31m-        print "\tcmd=$cmd\n" if $verbose;[m
[31m-        system($cmd) == 0[m
[31m-          or die "system($cmd) failed with exit code: $?"[m
[31m-          if !$dryRun;[m
[32m+[m[32m        while ( !( -e $rForSeqsFq ) ) { sleep 1; }[m
[32m+[m[32m        execute_and_log([m
[32m+[m[32m"qsub -cwd -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log -V $step3 -i $rForSeqsFq --file_type fastq -o $r1seqs",[m
[32m+[m[32m            0, $dryRun[m
[32m+[m[32m        );[m
 [m
[31m-        while ( !( -e $r4fq ) ) { sleep 1; }[m
[31m-        $cmd =[m
[31m-"qsub -cwd -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log -V split_sequence_file_on_sample_ids.py -i $r4fq --file_type fastq -o $r4seqs";[m
[31m-        print "\tcmd=$cmd\n" if $verbose;[m
[31m-        system($cmd) == 0[m
[31m-          or die "system($cmd) failed with exit code: $?"[m
[31m-          if !$dryRun;[m
[32m+[m[32m        while ( !( -e $rRevSeqsFq ) ) { sleep 1; }[m
[32m+[m[32m        execute_and_log([m
[32m+[m[32m"qsub -cwd -b y -l mem_free=1G -P $qproj -q threaded.q -pe thread 4 -V -e $error_log -o $stdout_log -V $step3 -i $rRevSeqsFq --file_type fastq -o $r4seqs",[m
[32m+[m[32m            0, $dryRun[m
[32m+[m[32m        );[m
 [m
         check_error_log( $error_log, $step3 );[m
 [m
[36m@@ -866,7 +827,7 @@[m [mif ( !@dbg || grep( /^demultiplex$/, @dbg ) ) {[m
         my $nLines = 0;[m
 [m
         # Count the number of lines in R1split/seqs.fastq[m
[31m-        open R1, "<$r1split/seqs.fastq";[m
[32m+[m[32m        open R1, "<$rForSplit/seqs.fastq";[m
         while (<R1>) { }[m
         my $R1lines = $.;[m
         close R1;[m
[36m@@ -896,7 +857,7 @@[m [mif ( !@dbg || grep( /^demultiplex$/, @dbg ) ) {[m
         $nLines = 0;[m
 [m
         # Count the number of lines in R4split/seqs.fastq[m
[31m-        open R4, "<$r4split/seqs.fastq";[m
[32m+[m[32m        open R4, "<$rRevSplit/seqs.fastq";[m
         while (<R4>) { }[m
         my $R4lines = $.;[m
         close R4;[m
[36m@@ -926,6 +887,17 @@[m [mif ( !@dbg || grep( /^demultiplex$/, @dbg ) ) {[m
         print $logFH "$newSamNo sample-specific files present as expected.\n";[m
     }[m
 [m
[32m+[m[32m    # Remove temporarily decompressed files[m
[32m+[m[32m    print "---Removing decompressed raw files from $wd\n";[m
[32m+[m
[32m+[m[32m    @cmds = ();[m
[32m+[m[32m    push( @cmds, "rm -rf $wd/${run}_R1.fastq" );[m
[32m+[m[32m    push( @cmds, "rm -rf $wd/${run}_R2.fastq" );[m
[32m+[m[32m    push( @cmds, "rm -rf $wd/${run}_R3.fastq" );[m
[32m+[m[32m    push( @cmds, "rm -rf $wd/${run}_I1.fastq" );[m
[32m+[m[32m    push( @cmds, "rm -rf $wd/${run}_I2.fastq" );[m
[32m+[m[32m    execute_and_log( @cmds, 0, $dryRun );[m
[32m+[m
     if ( @dbg && !grep( /^tagclean$/, @dbg ) ) {[m
         die[m
 "Finished extracting barcodes and demultiplexing libraries. Terminated "[m
[36m@@ -946,6 +918,8 @@[m [mmy @r4tcfiles = glob("$wd/*R2_tc.fastq");[m
 [m
 my $start = time;[m
 if ( !@dbg || grep( /^tagclean$/, @dbg ) ) {[m
[32m+[m[32m    my $nSamples = count_samples($map);[m
[32m+[m
     if ( !( defined $newSamNo ) ) {[m
         open SPLIT, "<$split_log"[m
           or die "Cannot open $split_log for writing: $OS_ERROR";[m
[36m@@ -977,8 +951,9 @@[m [mif ( !@dbg || grep( /^tagclean$/, @dbg ) ) {[m
                 while ( $filename = readdir R1 ) {[m
                     if ( $filename =~ /.fastq/ ) {[m
                         my @suffixes = ( ".fastq", ".fq" );[m
[31m-                        my $Prefix   = basename( $filename, @suffixes );[m
[31m-                        my $tc       = "$wd/$Prefix" . "_R2_tc";[m
[32m+[m[32m                        my $Prefix =[m
[32m+[m[32m                          File::Basename::basename( $filename, @suffixes );[m
[32m+[m[32m                        my $tc = "$wd/$Prefix" . "_R2_tc";[m
                         $cmd =[m
 "perl /usr/local/packages/tagcleaner-0.16/bin/tagcleaner.pl -fastq $r1seqs/$filename -out $tc -line_width 0 -verbose -tag5 GGACTACHVGGGTWTCTAAT -mm5 2 -trim_within 50";[m
                         print "\tcmd=$cmd\n" if $verbose;[m
[36m@@ -992,8 +967,9 @@[m [mif ( !@dbg || grep( /^tagclean$/, @dbg ) ) {[m
                 opendir R4, $r4seqs or die "Cannot open directory $r4seqs\n";[m
                 while ( $filename = readdir R4 ) {[m
                     my @suffixes = ( ".fastq", ".fq" );[m
[31m-                    my $Prefix   = basename( $filename, @suffixes );[m
[31m-                    my $tc       = "$wd/$Prefix" . "_R1_tc";[m
[32m+[m[32m                    my $Prefix =[m
[32m+[m[32m                      File::Basename::basename( $filename, @suffixes );[m
[32m+[m[32m                    my $tc = "$wd/$Prefix" . "_R1_tc";[m
                     $cmd =[m
 "perl /usr/local/packages/tagcleaner-0.16/bin/tagcleaner.pl -fastq $r4seqs/$filename -out $tc -line_width 0 -verbose -tag5 ACTCCTACGGGAGGCAGCAG -mm5 2 -trim_within 50";[m
                     print "\tcmd=$cmd\n" if $verbose;[m
[36m@@ -1011,8 +987,9 @@[m [mif ( !@dbg || grep( /^tagclean$/, @dbg ) ) {[m
                 while ( $filename = readdir R1 ) {[m
                     if ( $filename =~ /.fastq/ ) {[m
                         my @suffixes = ( ".fastq", ".fq" );[m
[31m-                        my $Prefix   = basename( $filename, @suffixes );[m
[31m-                        my $tc       = "$wd/$Prefix" . "_R1_tc";[m
[32m+[m[32m                        my $Prefix =[m
[32m+[m[32m                          File::Basename::basename( $filename, @suffixes );[m
[32m+[m[32m                        my $tc = "$wd/$Prefix" . "_R1_tc";[m
                         $cmd =[m
 "qsub -cwd -b y -l mem_free=200M -P $qproj -V -e $error_log -o $stdout_log perl /usr/local/packages/tagcleaner-0.16/bin/tagcleaner.pl -fastq $r1seqs/$filename -out $tc -line_width 0 -verbose -tag5 GTGCCAGCMGCCGCGGTAA -mm5 2";[m
                         print "\tcmd=$cmd\n" if $verbose;[m
[36m@@ -1026,8 +1003,9 @@[m [mif ( !@dbg || grep( /^tagclean$/, @dbg ) ) {[m
                 opendir R4, $r4seqs or die "Cannot open directory $r4seqs\n";[m
                 while ( $filename = readdir R4 ) {[m
                     my @suffixes = ( ".fastq", ".fq" );[m
[31m-                    my $Prefix   = basename( $filename, @suffixes );[m
[31m-                    my $tc       = "$wd/$Prefix" . "_R2_tc";[m
[32m+[m[32m                    my $Prefix =[m
[32m+[m[32m                      File::Basename::basename( $filename, @suffixes );[m
[32m+[m[32m                    my $tc = "$wd/$Prefix" . "_R2_tc";[m
                     $cmd =[m
 "qsub -cwd -b y -l mem_free=200M -P $qproj -V -e $error_log -o $stdout_log perl /usr/local/packages/tagcleaner-0.16/bin/tagcleaner.pl -fastq $r4seqs/$filename -out $tc -line_width 0 -verbose -tag5 ACTCCTACGGGAGGCAGCAG -mm5 2";[m
                     print "\tcmd=$cmd\n" if $verbose;[m
[36m@@ -1045,9 +1023,10 @@[m [mif ( !@dbg || grep( /^tagclean$/, @dbg ) ) {[m
                 while ( $filename = readdir R1 ) {[m
                     if ( $filename =~ /.fastq/ ) {[m
                         my @suffixes = ( ".fastq", ".fq" );[m
[31m-                        my $Prefix   = basename( $filename, @suffixes );[m
[31m-                        my $tc       = "$wd/$Prefix" . "_R1_tc";[m
[31m-                        [m
[32m+[m[32m                        my $Prefix =[m
[32m+[m[32m                          File::Basename::basename( $filename, @suffixes );[m
[32m+[m[32m                        my $tc = "$wd/$Prefix" . "_R1_tc";[m
[32m+[m
                         $cmd =[m
 "qsub -cwd -b y -l mem_free=200M -P $qproj -V -e $error_log -o $stdout_log perl /usr/local/packages/tagcleaner-0.16/bin/tagcleaner.pl -fastq $r1seqs/$filename -out $tc -line_width 0 -verbose -tag5 ACTCCTACGGGAGGCAGCAG -mm5 2";[m
 [m
[36m@@ -1063,8 +1042,9 @@[m [mif ( !@dbg || grep( /^tagclean$/, @dbg ) ) {[m
                 while ( $filename = readdir R4 ) {[m
                     if ( $filename =~ /.fastq/ ) {[m
                         my @suffixes = ( ".fastq", ".fq" );[m
[31m-                        my $Prefix   = basename( $filename, @suffixes );[m
[31m-                        my $tc       = "$wd/$Prefix" . "_R2_tc";[m
[32m+[m[32m                        my $Prefix =[m
[32m+[m[32m                          File::Basename::basename( $filename, @suffixes );[m
[32m+[m[32m                        my $tc = "$wd/$Prefix" . "_R2_tc";[m
 [m
                         $cmd =[m
 "qsub -cwd -b y -l mem_free=200M -P $qproj -V -e $error_log -o $stdout_log perl /usr/local/packages/tagcleaner-0.16/bin/tagcleaner.pl -fastq $r4seqs/$filename -out $tc -line_width 0 -verbose -tag5 GGACTACHVGGGTWTCTAAT -mm5 2";[m
[36m@@ -1084,8 +1064,9 @@[m [mif ( !@dbg || grep( /^tagclean$/, @dbg ) ) {[m
                 while ( $filename = readdir R1 ) {[m
                     if ( $filename =~ /.fastq/ ) {[m
                         my @suffixes = ( ".fastq", ".fq" );[m
[31m-                        my $Prefix   = basename( $filename, @suffixes );[m
[31m-                        my $tc       = "$wd/$Prefix" . "_R1_tc";[m
[32m+[m[32m                        my $Prefix =[m
[32m+[m[32m                          File::Basename::basename( $filename, @suffixes );[m
[32m+[m[32m                        my $tc = "$wd/$Prefix" . "_R1_tc";[m
                         $cmd =[m
 "qsub -cwd -b y -l mem_free=200M -P $qproj -V -e $error_log -o $stdout_log perl /usr/local/packages/tagcleaner-0.16/bin/tagcleaner.pl -fastq $r1seqs/$filename -out $tc -line_width 0 -verbose -tag5 GTGCCAGCMGCCGCGGTAA -mm5 2";[m
                         print "\tcmd=$cmd\n" if $verbose;[m
[36m@@ -1099,8 +1080,9 @@[m [mif ( !@dbg || grep( /^tagclean$/, @dbg ) ) {[m
                 opendir R4, $r4seqs or die "Cannot open directory $r4seqs\n";[m
                 while ( $filename = readdir R4 ) {[m
                     my @suffixes = ( ".fastq", ".fq" );[m
[31m-                    my $Prefix   = basename( $filename, @suffixes );[m
[31m-                    my $tc       = "$wd/$Prefix" . "_R2_tc";[m
[32m+[m[32m                    my $Prefix =[m
[32m+[m[32m                      File::Basename::basename( $filename, @suffixes );[m
[32m+[m[32m                    my $tc = "$wd/$Prefix" . "_R2_tc";[m
                     $cmd =[m
 "qsub -cwd -b y -l mem_free=200M -P $qproj -V -e $error_log -o $stdout_log perl /usr/local/packages/tagcleaner-0.16/bin/tagcleaner.pl -fastq $r4seqs/$filename -out $tc -line_width 0 -verbose -tag5 ACTCCTACGGGAGGCAGCAG -mm5 2";[m
                     print "\tcmd=$cmd\n" if $verbose;[m
[36m@@ -1117,8 +1099,9 @@[m [mif ( !@dbg || grep( /^tagclean$/, @dbg ) ) {[m
                 while ( $filename = readdir R1 ) {[m
                     if ( $filename =~ /.fastq/ ) {[m
                         my @suffixes = ( ".fastq", ".fq" );[m
[31m-                        my $Prefix   = basename( $filename, @suffixes );[m
[31m-                        my $tc       = "$wd/$Prefix" . "_R1_tc";[m
[32m+[m[32m                        my $Prefix =[m
[32m+[m[32m                          File::Basename::basename( $filename, @suffixes );[m
[32m+[m[32m                        my $tc = "$wd/$Prefix" . "_R1_tc";[m
                         $cmd =[m
 "qsub -cwd -b y -l mem_free=200M -P $qproj -V -e $error_log -o $stdout_log perl /usr/local/packages/tagcleaner-0.16/bin/tagcleaner.pl -fastq $r1seqs/$filename -out $tc -line_width 0 -verbose -tag5 CTGCCCTTTGTACACACCGC -mm5 2";[m
                         print "\tcmd=$cmd\n" if $verbose;[m
[36m@@ -1132,8 +1115,9 @@[m [mif ( !@dbg || grep( /^tagclean$/, @dbg ) ) {[m
                 opendir R4, $r4seqs or die "Cannot open directory $r4seqs\n";[m
                 while ( $filename = readdir R4 ) {[m
                     my @suffixes = ( ".fastq", ".fq" );[m
[31m-                    my $Prefix   = basename( $filename, @suffixes );[m
[31m-                    my $tc       = "$wd/$Prefix" . "_R2_tc";[m
[32m+[m[32m                    my $Prefix =[m
[32m+[m[32m                      File::Basename::basename( $filename, @suffixes );[m
[32m+[m[32m                    my $tc = "$wd/$Prefix" . "_R2_tc";[m
                     $cmd =[m
 "qsub -cwd -b y -l mem_free=200M -P $qproj -V -e $error_log -o $stdout_log perl /usr/local/packages/tagcleaner-0.16/bin/tagcleaner.pl -fastq $r4seqs/$filename -out $tc -line_width 0 -verbose -tag5 TTTCGCTGCGTTCTTCATCG -mm5 2";[m
                     print "\tcmd=$cmd\n" if $verbose;[m
[36m@@ -1198,7 +1182,7 @@[m [mif ( ( !@dbg ) || grep( /^dada2$/, @dbg ) ) {[m
           if !$dryRun;[m
 [m
         print "Running DADA2 with fastq files in $wd\n";[m
[31m-        print $logFH "Running DADA2 for $var region";[m
[32m+[m[32m        print $logFH "Running DADA2 for $var region\n";[m
         chdir $pd;[m
         if ($oneStep) {[m
             if ( $var eq "V3V4" ) {[m
[36m@@ -1442,7 +1426,6 @@[m [mif ( ( !@dbg ) || grep( /^dada2$/, @dbg ) ) {[m
           . "$project run $run located at $wd/dada2_abundance_table.rds\n";[m
         print $logFH "See $dadaTbl for dada2 table of reads surviving by "[m
           . "step\n";[m
[31m-        close $logFH;[m
     } else {[m
         print "---dada2 did not complete successfully, something went wrong!\n"[m
           . "---Check $projrtout.\n";[m
[36m@@ -1458,27 +1441,6 @@[m [mwhile (<$logFH>) {[m
         print "---Run-specific abundance table written to "[m
           . "$wd/dada2_abundance_table.rds\n";[m
         print "---See $log for processing details\n";[m
[31m-        print "---Removing original R1, R2, R3, and R4 files from $wd\n";[m
[31m-        $cmd = "rm -rf $r1";[m
[31m-        print "\tcmd=$cmd\n" if $verbose;[m
[31m-        system($cmd) == 0[m
[31m-          or die "system($cmd) failed with exit code: $?"[m
[31m-          if !$dryRun;[m
[31m-        $cmd = "rm -rf $r2";[m
[31m-        print "\tcmd=$cmd\n" if $verbose;[m
[31m-        system($cmd) == 0[m
[31m-          or die "system($cmd) failed with exit code: $?"[m
[31m-          if !$dryRun;[m
[31m-        $cmd = "rm -rf $r3";[m
[31m-        print "\tcmd=$cmd\n" if $verbose;[m
[31m-        system($cmd) == 0[m
[31m-          or die "system($cmd) failed with exit code: $?"[m
[31m-          if !$dryRun;[m
[31m-        $cmd = "rm -rf $r4";[m
[31m-        print "\tcmd=$cmd\n" if $verbose;[m
[31m-        system($cmd) == 0[m
[31m-          or die "system($cmd) failed with exit code: $?"[m
[31m-          if !$dryRun;[m
     }[m
 }[m
 print $logFH "\n";[m
[36m@@ -1492,6 +1454,142 @@[m [mclose $logFH;[m
 ####################################################################[m
 ##                               SUBS[m
 ####################################################################[m
[32m+[m[32m# @param 0 mapping file path[m
[32m+[m[32msub count_samples {[m
[32m+[m[32m    my $map = shift;[m
[32m+[m[32m    open my $mapFH, "<$map" or die "Cannot open $map for reading: $OS_ERROR";[m
[32m+[m[32m    while (<$mapFH>) { }[m
[32m+[m[32m    my $ans = $. - 1;[m
[32m+[m[32m    close $mapFH;[m
[32m+[m[32m    return $ans;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m# @param 0 original input directory[m
[32m+[m[32m# @param 1 whether one-step or not[m
[32m+[m[32m# @param 2 a scalar file handle to write logs to[m
[32m+[m[32msub find_raw_files {[m
[32m+[m[32m    my $index1Input;[m
[32m+[m[32m    my $index2Input;[m
[32m+[m[32m    my $readsForInput;[m
[32m+[m[32m    my $readsRevInput;[m
[32m+[m[32m    my ( $wd, $oneStep, $logFH ) = @_;[m
[32m+[m
[32m+[m[32m    # These are the only input files needed for 1step[m
[32m+[m[32m    my @r1s = glob("$wd/*R1.fastq $wd/*R1.fastq.gz");[m
[32m+[m[32m    my @r2s = glob("$wd/*R2.fastq $wd/*R2.fastq.gz");[m
[32m+[m
[32m+[m[32m    # my @r3s = glob("$inDir/*R3.fastq $inDir/*R3.fastq.gz");[m
[32m+[m[32m    # my @r4s = glob("$inDir/*R4.fastq $inDir/*R4.fastq.gz");[m
[32m+[m[32m    if ($oneStep) {[m
[32m+[m[32m        if ([m
[32m+[m[32m               scalar @r1s == 1[m
[32m+[m[32m            && scalar @r2s == 1[m
[32m+[m
[32m+[m[32m            # && scalar @r3s == 1[m
[32m+[m[32m            # && scalar @r4s == 1[m
[32m+[m[32m          )[m
[32m+[m[32m        {[m
[32m+[m[32m            $index1Input = $readsForInput = $r1s[0];[m
[32m+[m[32m            $index2Input = $readsRevInput = $r2s[0];[m
[32m+[m[32m        } else {[m
[32m+[m[32m            print $logFH "Couldn't find input files in $wd.\n";[m
[32m+[m[32m            print $logFH "Files found:\n";[m
[32m+[m
[32m+[m[32m            my $printme = join "\n", @r1s;[m
[32m+[m[32m            print $logFH "$printme\n" if $printme;[m
[32m+[m[32m            $printme = join "\n", @r2s;[m
[32m+[m[32m            print $logFH "$printme\n" if $printme;[m
[32m+[m
[32m+[m[32m            # $printme = join "\n", @r3s;[m
[32m+[m[32m            # print $logFH "$printme\n" if $printme;[m
[32m+[m[32m            # $printme = join "\n", @r4s;[m
[32m+[m[32m            # print $logFH "$printme\n" if $printme;[m
[32m+[m[32m            die[m
[32m+[m[32m"Could not find a complete and exclusive set of raw files. Since --1step given, input directory must"[m
[32m+[m[32m              . " have exactly one R1, and R2 file. See pipeline log for a list of the files"[m
[32m+[m[32m              . " found.";[m
[32m+[m[32m        }[m
[32m+[m[32m    } else {[m
[32m+[m[32m        my @i1s = glob("$wd/*I1.fastq $wd/*I1.fastq.gz");[m
[32m+[m[32m        my @i2s = glob("$wd/*I2.fastq $wd/*I2.fastq.gz");[m
[32m+[m
[32m+[m[32m        # also globbed for r1 and r2 files above[m
[32m+[m[32m        my @r3s = glob("$wd/*R3.fastq $wd/*R3.fastq.gz");[m
[32m+[m[32m        my @r4s = glob("$wd/*R4.fastq $wd/*R4.fastq.gz");[m
[32m+[m
[32m+[m[32m        if (   scalar @i1s == 1[m
[32m+[m[32m            && scalar @i2s == 1[m
[32m+[m[32m            && scalar @r1s == 1[m
[32m+[m[32m            && scalar @r2s == 1[m
[32m+[m[32m            && scalar @r3s == 0[m
[32m+[m[32m            && scalar @r4s == 0 )[m
[32m+[m[32m        {[m
[32m+[m[32m            $index1Input   = $i1s[0];[m
[32m+[m[32m            $index2Input   = $i2s[0];[m
[32m+[m[32m            $readsForInput = $r1s[0];[m
[32m+[m[32m            $readsRevInput = $r2s[0];[m
[32m+[m[32m        } elsif ( scalar @i1s == 0[m
[32m+[m[32m            && scalar @i2s == 0[m
[32m+[m[32m            && scalar @r1s == 1[m
[32m+[m[32m            && scalar @r2s == 1[m
[32m+[m[32m            && scalar @r3s == 1[m
[32m+[m[32m            && scalar @r4s == 1 )[m
[32m+[m[32m        {[m
[32m+[m[32m            $index1Input   = $r2s[0];[m
[32m+[m[32m            $index2Input   = $r3s[0];[m
[32m+[m[32m            $readsForInput = $r1s[0];[m
[32m+[m[32m            $readsRevInput = $r4s[0];[m
[32m+[m[32m        } else {[m
[32m+[m[32m            print $logFH "Couldn't find input files.\n";[m
[32m+[m[32m            print $logFH "Files found in $wd:\n";[m
[32m+[m[32m            my $printme = join "\n", @i1s;[m
[32m+[m[32m            print $logFH "$printme\n" if $printme;[m
[32m+[m[32m            $printme = join "\n", @i2s;[m
[32m+[m[32m            print $logFH "$printme\n" if $printme;[m
[32m+[m[32m            $printme = join "\n", @r1s;[m
[32m+[m[32m            print $logFH "$printme\n" if $printme;[m
[32m+[m[32m            $printme = join "\n", @r2s;[m
[32m+[m[32m            print $logFH "$printme\n" if $printme;[m
[32m+[m[32m            $printme = join "\n", @r3s;[m
[32m+[m[32m            print $logFH "$printme\n" if $printme;[m
[32m+[m[32m            $printme = join "\n", @r4s;[m
[32m+[m[32m            print $logFH "$printme\n" if $printme;[m
[32m+[m[32m            die[m
[32m+[m[32m"Could not find a complete and exclusive set of raw files. Input directory must"[m
[32m+[m[32m              . " contain exactly one set of I1, I2, R1, and R2, OR R1, R2, R3, and R4.\n"[m
[32m+[m[32m              . "See pipeline log for a list of the files found.";[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    return ( $readsForInput, $readsRevInput, $index1Input, $index2Input );[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m# Given *R1.fastq(.gz), if it's .gz, then removes the extension and gives a[m
[32m+[m[32m# filepath in the local directory[m
[32m+[m[32m# @param 0 The project/run directory[m
[32m+[m[32m# @params 1... The full path to the original file[m
[32m+[m[32msub convert_to_local_if_gz {[m
[32m+[m[32m    my $wd    = shift;[m
[32m+[m[32m    my @files = @_;[m
[32m+[m[32m    my @ans;[m
[32m+[m[32m    foreach my $file (@files) {[m
[32m+[m[32m        if ( $file =~ /.gz$/ ) {[m
[32m+[m
[32m+[m[32m            # Rename *[R|I][1|2].fastq.gz to <WD>/<PROJ>_<RUN>_[R|I][1|2].fastq[m
[32m+[m[32m            my $dest = File::Basename::basename($file);[m
[32m+[m
[32m+[m[32m            my $suffix = substr( $dest, ( length($dest) - 11 ), 8 )[m
[32m+[m[32m              ;    # get suffix (sans .gz)[m
[32m+[m
[32m+[m[32m            my @dirs = File::Spec->splitdir($wd);[m
[32m+[m[32m            $file =[m
[32m+[m[32m                "$wd/$dirs[scalar(@dirs) - 2]" . "_"[m
[32m+[m[32m              . "$dirs[scalar(@dirs) - 1]"[m
[32m+[m[32m              . "_$suffix";[m
[32m+[m[32m        }[m
[32m+[m[32m        push( @ans, $file );[m
[32m+[m[32m    }[m
[32m+[m[32m    return @ans;[m
[32m+[m[32m}[m
 [m
 sub dada2 {[m
     my $run      = shift;[m
[36m@@ -1589,7 +1687,7 @@[m [msub run_R_script {[m
     close OUT;[m
 [m
     my $cmd = "$R CMD BATCH $outFile";[m
[31m-    print "$cmd";[m
[32m+[m[32m    print "cmd=$cmd";[m
     system($cmd) == 0 or die "system($cmd) failed:$?\n";[m
 [m
     my $outR = $outFile . "out";[m
[36m@@ -1655,4 +1753,24 @@[m [msub check_error_log {[m
     close ERROR;[m
 }[m
 [m
[32m+[m[32m################################################################################[m
[32m+[m[32m# Execute the given commands;[m
[32m+[m[32m# the second to last argument must evaluate false to prevent loggin to log file.[m
[32m+[m[32m# the last argument is 1 if this is a dry run[m
[32m+[m[32msub execute_and_log {[m
[32m+[m[32m    my $dryRun = pop @_;[m
[32m+[m[32m    my $logFH  = pop @_;[m
[32m+[m
[32m+[m[32m    # CAREFUL, $cmd holds a reference to a variable in the caller![m
[32m+[m[32m    foreach my $cmd (@_) {[m
[32m+[m[32m        print "\t$cmd\n" if $verbose;[m
[32m+[m[32m        if ($logFH) {[m
[32m+[m[32m            print $logFH "\t$cmd\n";[m
[32m+[m[32m        }[m
[32m+[m[32m        system($cmd) == 0[m
[32m+[m[32m          or die "system($cmd) failed with exit code: $?"[m
[32m+[m[32m          if !$dryRun;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
 exit 0;[m
